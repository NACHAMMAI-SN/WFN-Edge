using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

using Wokhan.WindowsFirewallNotifier.Common.Net.IP;
using Wokhan.WindowsFirewallNotifier.Common.Net.IP.NativeOverrides;

namespace Windows.Win32.NetworkManagement.IpHelper;

/// <summary>
/// IMPORTANT: Never add any field or setter to this struct, as it is PARTIAL and relies on fields generated by CsWin32 P/Invoke source generator.
/// If you do this, fields order might be broken and P/Invoke will fail (the struct layout in memory being unpredictable for partial structs).
/// </summary>
internal partial struct MIB_TCP6ROW_OWNER_MODULE : IConnectionOwnerInfo
{
    unsafe uint IConnectionOwnerInfo.GetOwnerModule(IntPtr buffer, ref uint buffSize)
    {
        return NativeMethods.GetOwnerModuleFromTcp6Entry(in this, TCPIP_OWNER_MODULE_INFO_CLASS.TCPIP_OWNER_MODULE_INFO_BASIC, buffer.ToPointer(), ref buffSize);
    }

    unsafe TCP_ESTATS_BANDWIDTH_ROD_v0? IConnectionOwnerInfo.GetPerTcpConnectionEState(MIB_TCP6ROW? tcp6Row)
    {
        if (tcp6Row is null)
        {
            return null;
        }

        var rw = new TCP_ESTATS_BANDWIDTH_RW_v0() { EnableCollectionInbound = TCP_BOOLEAN_OPTIONAL.TcpBoolOptEnabled, EnableCollectionOutbound = TCP_BOOLEAN_OPTIONAL.TcpBoolOptEnabled };
        var rod = new TCP_ESTATS_BANDWIDTH_ROD_v0();

        var row = tcp6Row.Value;

        var ret = NativeMethods.GetPerTcp6ConnectionEStats(&row, TCP_ESTATS_TYPE.TcpConnectionEstatsBandwidth, (byte*)&rw, 0, MarshalHelper.rwS, null, 0, 0, (byte*)&rod, 0, MarshalHelper.rodS);

        if (ret == 0 && rw.EnableCollectionInbound == TCP_BOOLEAN_OPTIONAL.TcpBoolOptEnabled && rw.EnableCollectionOutbound == TCP_BOOLEAN_OPTIONAL.TcpBoolOptEnabled)
        {
            return rod;
        }

        return null;
    }

    unsafe uint IConnectionOwnerInfo.SetPerTcpConnectionEStats(ref TCP_ESTATS_BANDWIDTH_RW_v0 rw, MIB_TCP6ROW? tcp6Row)
    {
        if (tcp6Row is null)
        {
            return 87; // ERROR_INVALID_PARAMETER
        }

        var row = tcp6Row.Value;
        fixed (void* rwPtr = &rw)
        {
            return NativeMethods.SetPerTcp6ConnectionEStats(&row, TCP_ESTATS_TYPE.TcpConnectionEstatsBandwidth, (byte*)rwPtr, 0, MarshalHelper.rwS, 0);
        }
    }
}
